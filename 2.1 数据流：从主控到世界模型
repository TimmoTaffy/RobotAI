# 数据流设计：从主控到世界模型

下面用一个端到端的流程图来说明“主控 → 串口接收 → 数据分发 → 模块处理 → world_model”各环节的职责和数据流：

1. 主控发送数据
• 目的：主控通过 USB 串口发送所有传感器数据（IMU、电调反馈、激光雷达、雷达站、视觉结果，以及云台姿态）
• 输出：JSON 格式的结构化数据，例如：
  {
      "sensor": "IMU",
      "gyro": [0.1, 0.2, 0.3],
      "acc": [0.0, 0.0, -9.8],
      "yaw": 1.57,
      "timestamp": 1234567.89
  }

2. 串口接收（SerialReceiver）
• 目的：通过 `serial_receiver.py` 接收主控发送的 JSON 数据
• 输出：带有时间戳的原始数据，推送到队列中

3. 数据分发
• 目的：各传感器模块（如 IMU、WheelEncoder、Lidar、Magnetometer、BaseGyro 等）从队列中提取自己关心的数据
• 举例：
  - IMU 模块提取 "sensor": "IMU" 的数据
  - WheelEncoder 模块提取 "sensor": "WheelEncoder" 的数据
  - Magnetometer 模块提取 "sensor": "Magnetometer" 的数据
• 输出：模块内部用的原始测量数据

4. 模块处理
• 目的：各功能模块对数据进行处理和融合
• 举例：
  - Dead Reckoning：根据轮速推算位姿
  - EKF：融合 IMU、磁力计、底盘陀螺仪和轮速数据，估计自车状态
  - LidarProcessor：处理激光雷达点云，提取障碍物
  - TargetTracker：融合雷达站和视觉数据，跟踪目标
  - TurretPose：估计云台姿态（俯仰角和偏航角）
    - 从串口接收陀螺仪、磁力计和电机角度数据
    - 调用 turret_pose.py 解算俯仰角和偏航角
    - 输出云台姿态数据和电机角度

5. 更新 WorldModel
• 目的：将所有模块的输出统一填充到 `WorldModel` 对象中
• 举例：
  wm.self_pose = SelfPose(x, y, θ, v, turret_pitch=pitch, turret_yaw=yaw, horizontal_motor=horizontal_angle, vertical_motor=vertical_angle)
  wm.enemy_targets = [EnemyTarget(...), …]
  wm.static_obstacles = [...]
  wm.dynamic_obstacles = [...]
  wm.turret_pose = TurretPose(pitch, yaw)
• 最终：一个包含全场态势的 `WorldModel`，供决策、路径规划和可视化使用

——————

整条链路的核心思想是“集中接收＋模块化处理＋统一输出”：

1. 主控集中发送所有传感器数据 → 2. 串口接收并分发 → 3. 各模块独立处理 → 4. 统一填充到 `WorldModel`。

这样做的好处：

- 数据流清晰，所有传感器数据通过串口集中管理
- 各模块职责独立，易于调试和扩展
- `WorldModel` 提供单一数据入口，方便上层规划与可视化统一调用